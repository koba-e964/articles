- ソフトウェア開発
  - 設計技術
    - クリーンアーキテクチャー
    - マイクロサービス vs モノリス
    - ドメイン駆動設計
    - API の設計
    - データの設計
    - ユースケースの想定
    - 用件定義 (Requirement Analysis)
    - プロダクトマネジメント基礎
    - MVP 設計
    - ユーザーストーリーマッピング
    - 技術選定と意思決定のドキュメント化
      - ADR
  - 実装技術
    - Deterministic で副作用のない実装
    - immutability を尊重した実装
    - テスト
      - 単体テスト
      - プロパティベーステスト
      - ストレステスト
    - コミット分割
    - PR 分割
  - チーム開発
    - リリース管理
    - バージョン付け
      - SemVer
      - データの互換性
  - 理論
    - CPU についての知識
      - キャッシュ
      - ALU・レジスター・メモリー・外部記憶
      - 機械語
    - 計算量理論・アルゴリズム・データ構造
    - 暗号理論
      - 公開鍵暗号方式
      - 共通鍵暗号方式
      - ハッシュ関数
    - 非同期処理・並行プログラミング
      - 一貫性モデル
    - 型理論
    - コンパイラー・言語処理系
      - 構文解析
      - 意味解析
      - 最適化
    - 統計・機械学習
  - セキュリティー
    - CIA
    - リスク評価
    - usable security
    - 権限最小化
    - Zero-trust architecture
    - 依存関係の自動スキャン (SBOM)
  - コード品質
    - cyclotomic complexity
  - 運用
    - CI/CD 構築と運用
      - lint, test, format, e2e...
    - ビルド
      - make, cmake, cargo, ...
    - デプロイ
      - Docker
      - Kubernetes
    - DB のマイグレーション
    - クラウド
      - スケールアップ・スケールダウン
      - Serverless architecture
    - 監視 / Observability
      - ログ
      - メトリクス
      - トレース
    - アラート送出
    - IaC (infrastructure as code)
    - SRE
      - SLO/SLA/SLI
      - エラーバジェット
      - インシデントレスポンス
      - ポストモーテム文化
  - UX (user experience)
  - ソフトスキル・チーム開発技術
    - コードレビューガイドライン
    - 技術的負債の優先度付けと管理
    - Scrum/Kanban 運用実践
    - ナレッジ共有の仕組みづくり
    - オンボーディング設計
  - 法律・ライセンス・コンプライアンス
  - データ分析
    - データウェアハウス
    - 処理基盤
    - データガバナンス・セキュリティー
    - 可視化
